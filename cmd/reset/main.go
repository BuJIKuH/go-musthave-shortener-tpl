// Package main реализует утилиту генерации функций Reset() для структур,
// помеченных комментарием // generate:reset. Утилита сканирует все
// пакеты проекта и создаёт файл reset.gen.go с методами Reset().
package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
)

// main запускает утилиту генерации Reset() методов.
func main() {
	rootDir := "." // корень проекта

	// Проходим по всем файлам проекта
	err := filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Игнорируем директорию самой утилиты
		if info.IsDir() && strings.HasSuffix(path, "cmd/reset") {
			return filepath.SkipDir
		}

		if !info.IsDir() && strings.HasSuffix(path, ".go") && !strings.HasSuffix(path, "_test.go") {
			if err := processFile(path); err != nil {
				log.Printf("Ошибка обработки %s: %v", path, err)
			}
		}
		return nil
	})
	if err != nil {
		log.Fatal(err)
	}
}

// processFile парсит Go-файл и ищет структуры с комментарием // generate:reset.
// Если структуры найдены, генерирует методы Reset() и записывает их в reset.gen.go.
func processFile(filePath string) error {
	fset := token.NewFileSet()
	fileNode, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("не удалось распарсить файл: %w", err)
	}

	pkgName := fileNode.Name.Name
	var resets []string

	for _, decl := range fileNode.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec := spec.(*ast.TypeSpec)
			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				continue
			}

			// Проверяем комментарий над структурой
			if genDecl.Doc != nil {
				for _, comment := range genDecl.Doc.List {
					if strings.Contains(comment.Text, "generate:reset") {
						resetCode := generateResetMethod(typeSpec.Name.Name, structType)
						resets = append(resets, resetCode)
					}
				}
			}
		}
	}

	if len(resets) == 0 {
		return nil
	}

	// Создаём файл reset.gen.go
	genFile := filepath.Join(filepath.Dir(filePath), "reset.gen.go")
	f, err := os.Create(genFile)
	if err != nil {
		return fmt.Errorf("не удалось создать файл: %w", err)
	}
	defer f.Close()

	// Пишем заголовок
	if _, err := f.WriteString("// Code generated by cmd/reset. DO NOT EDIT.\n\n"); err != nil {
		return fmt.Errorf("не удалось записать заголовок: %w", err)
	}
	if _, err := f.WriteString(fmt.Sprintf("package %s\n\n", pkgName)); err != nil {
		return fmt.Errorf("не удалось записать package: %w", err)
	}

	// Пишем каждый метод Reset()
	for _, method := range resets {
		if _, err := f.WriteString(method + "\n\n"); err != nil {
			return fmt.Errorf("не удалось записать метод: %w", err)
		}
	}

	fmt.Printf("Сгенерировано %d методов Reset() в %s\n", len(resets), genFile)
	return nil
}

// generateResetMethod создаёт метод Reset() для структуры.
func generateResetMethod(structName string, st *ast.StructType) string {
	code := fmt.Sprintf("func (s *%s) Reset() {\n", structName)
	code += "    if s == nil {\n        return\n    }\n"

	for _, field := range st.Fields.List {
		if len(field.Names) == 0 {
			continue
		}
		fieldName := field.Names[0].Name
		code += generateResetForField(fieldName, field.Type)
	}

	code += "}\n"
	return code
}

// generateResetForField создаёт строку кода для сброса одного поля по типу.
// generateResetForField создаёт строку кода для сброса одного поля по типу.
func generateResetForField(name string, expr ast.Expr) string {
	switch t := expr.(type) {

	case *ast.Ident:
		switch t.Name {
		case "int", "int64", "uint", "uint64", "float32", "float64":
			return fmt.Sprintf("    s.%s = 0\n", name)
		case "string":
			return fmt.Sprintf("    s.%s = \"\"\n", name)
		case "bool":
			return fmt.Sprintf("    s.%s = false\n", name)
		default:
			// Если это вложенная структура с Reset()
			return fmt.Sprintf(
				"    if resetter, ok := interface{}(s.%s).(interface{ Reset() }); ok {\n        resetter.Reset()\n    }\n",
				name,
			)
		}

	case *ast.StarExpr:
		inner := t.X
		// Для указателей сначала проверяем nil, потом разыменовываем
		switch ident := inner.(type) {
		case *ast.Ident:
			switch ident.Name {
			case "int", "int64", "uint", "uint64", "float32", "float64":
				return fmt.Sprintf("    if s.%s != nil {\n        *s.%s = 0\n    }\n", name, name)
			case "string":
				return fmt.Sprintf("    if s.%s != nil {\n        *s.%s = \"\"\n    }\n", name, name)
			case "bool":
				return fmt.Sprintf("    if s.%s != nil {\n        *s.%s = false\n    }\n", name, name)
			default:
				// вложенная структура через Reset()
				return fmt.Sprintf("    if s.%s != nil {\n        if resetter, ok := interface{}(s.%s).(interface{ Reset() }); ok {\n            resetter.Reset()\n        }\n    }\n", name, name)
			}
		default:
			return fmt.Sprintf("    // TODO: сброс указателя %s\n", name)
		}

	case *ast.ArrayType:
		return fmt.Sprintf("    s.%s = s.%s[:0]\n", name, name)

	case *ast.MapType:
		return fmt.Sprintf(
			"    if s.%s != nil {\n        for k := range s.%s {\n            delete(s.%s, k)\n        }\n    }\n",
			name, name, name,
		)

	default:
		return fmt.Sprintf("    // TODO: сброс для %s\n", name)
	}
}

// indent добавляет отступ к каждой строке кода.
func indent(code string, level int) string {
	prefix := strings.Repeat("    ", level)
	lines := strings.Split(code, "\n")
	for i := range lines {
		if len(strings.TrimSpace(lines[i])) > 0 {
			lines[i] = prefix + lines[i]
		}
	}
	return strings.Join(lines, "\n")
}
